// src/app/api/crawl/route.ts - Hyper-Crawler v4.1 (AI-Powered Edition)

import { NextResponse } from "next/server";
import * as cheerio from "cheerio";
import { HuggingFaceTransformersEmbeddings } from "@langchain/community/embeddings/hf_transformers";
import { chromium, Browser, Page } from "playwright";
import { Document } from "langchain/document";
import { createClient } from "@supabase/supabase-js";
import { v4 as uuidv4 } from "uuid";

// ============================================
// ğŸ§  Ù†Ø¸Ø§Ù… Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ø°ÙƒÙŠ Ø§Ù„Ù…Ø­Ø³Ù† (Ultimate Edition)
// ============================================

interface SmartWaitResult {
  success: boolean;
  strategy: string;
  timeSpent: number;
  linksFound: number;
  contentQuality: number;
  criticalContentFound: boolean;
  productsDetected: number;
}

async function intelligentWaitStrategyV4(
  page: Page,
  url: string,
  taskNum: number
): Promise<SmartWaitResult> {
  const startTime = Date.now();
  let strategy = "unknown";
  let criticalContentFound = false;
  let productsDetected = 0;

  try {
    // ========================================
    // ğŸ” Ø§Ù„Ù…Ø³ØªÙˆÙ‰ 0: ÙƒØ´Ù Ø§Ù„Ù…Ù†ØµØ© Ø£ÙˆÙ„Ø§Ù‹
    // ========================================
    console.log(`  [Task ${taskNum}] ğŸ” Platform detection...`);
    
    const platformDetection = await page.evaluate(() => {
      const html = document.documentElement.outerHTML;
      const isSalla = 
        html.includes('salla.sa') || 
        html.includes('salla-bundle') ||
        document.querySelector('script[src*="salla"]') !== null;
      
      const isZid = 
        html.includes('zid.sa') || 
        html.includes('zid-platform') ||
        document.querySelector('script[src*="zid"]') !== null;
      
      const isNextJS = document.querySelector('script#__NEXT_DATA__') !== null;

      return { isSalla, isZid, isNextJS };
    });

    const platform = platformDetection.isSalla ? "Salla" : 
                    platformDetection.isZid ? "Zid" : 
                    platformDetection.isNextJS ? "NextJS" : "Generic";
    
    console.log(`  [Task ${taskNum}] ğŸª Detected platform: ${platform}`);

    // ========================================
    // ğŸ¯ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ 1: Ø§Ù†ØªØ¸Ø§Ø± Ù…Ø­Ø¯Ø¯ Ø­Ø³Ø¨ Ø§Ù„Ù…Ù†ØµØ©
    // ========================================
    if (platformDetection.isSalla) {
      console.log(`  [Task ${taskNum}] â³ Salla platform - enhanced waiting...`);
      
      // Ù…Ø­Ø¯Ø¯Ø§Øª Salla Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©
      const sallaSelectors = [
        '.s-block-product-card',
        '[data-product-id]',
        '.product-entry',
        '.s-product-card-entry',
        '.s-block-product-card__name'
      ];
      
      for (const selector of sallaSelectors) {
        try {
          await page.waitForSelector(selector, { timeout: 5000 });
          console.log(`  [Task ${taskNum}] âœ… Found Salla selector: ${selector}`);
          criticalContentFound = true;
          break;
        } catch (e) {
          // continue to next selector
        }
      }
      
      // Ø§Ù†ØªØ¸Ø§Ø± ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø´Ø¨ÙƒØ©
      await page.waitForLoadState('networkidle', { timeout: 10000 }).catch(() => {});
      
      // Ø§Ù†ØªØ¸Ø§Ø± Ø¥Ø¶Ø§ÙÙŠ Ù„Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ
      await page.waitForTimeout(3000);
      
      strategy = 'salla_optimized_v4';
    }
    else if (platformDetection.isZid) {
      console.log(`  [Task ${taskNum}] â³ Zid platform - enhanced waiting...`);
      
      await page.waitForSelector('.z-product-card, [data-zid-product], .z-product-page', { 
        timeout: 6000 
      }).catch(() => {});
      
      await page.waitForLoadState('networkidle', { timeout: 8000 }).catch(() => {});
      await page.waitForTimeout(2000);
      
      strategy = 'zid_optimized_v4';
      criticalContentFound = true;
    }
    else if (platformDetection.isNextJS) {
      console.log(`  [Task ${taskNum}] â³ NextJS platform - extended wait...`);
      
      await page.waitForLoadState('networkidle', { timeout: 12000 }).catch(() => {});
      await page.waitForTimeout(4000);
      
      strategy = 'nextjs_optimized_v4';
    }
    else {
      // Ø§Ù†ØªØ¸Ø§Ø± Ø¹Ø§Ù… Ù…Ø­Ø³Ù‘Ù†
      console.log(`  [Task ${taskNum}] â³ Generic platform enhanced wait...`);
      
      const genericSelectors = [
        '.product, .product-item, .product-card',
        '[class*="product"]',
        'h1, h2, h3',
        '[itemprop="name"]',
        '.price, [class*="price"]'
      ];
      
      for (const selector of genericSelectors) {
        try {
          await page.waitForSelector(selector, { timeout: 4000 });
          criticalContentFound = true;
          break;
        } catch (e) {}
      }
      
      await page.waitForLoadState('networkidle', { timeout: 8000 }).catch(() => {});
      strategy = 'generic_optimized_v4';
    }
    
    // ========================================
    // ğŸ“Š Ø§Ù„Ù…Ø³ØªÙˆÙ‰ 2: Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ø§Ù„Ù…Ø­Ø³Ù‘Ù†
    // ========================================
    const finalCheck = await page.evaluate(() => {
      // Ø¥Ø­ØµØ§Ø¡Ø§Øª Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª
      const productElements = document.querySelectorAll(
        '.product, .product-item, .product-card, [data-product-id], .s-block-product-card, .z-product-card'
      );
      
      const links = document.querySelectorAll('a[href]').length;
      const hasH1 = document.querySelector('h1') !== null;
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù…Ø­ØªÙˆÙ‰ Ø­Ù‚ÙŠÙ‚ÙŠ
      const hasRealContent = document.querySelector('h1') ? 
        (document.querySelector('h1')!.textContent!.trim().length > 3) : false;
      
      return { 
        products: productElements.length, 
        links, 
        hasH1,
        hasRealContent
      };
    });
    
    productsDetected = finalCheck.products;
    
    console.log(`  [Task ${taskNum}] ğŸ“Š Final check: Products=${finalCheck.products}, Links=${finalCheck.links}, RealContent=${finalCheck.hasRealContent}`);
    
    const timeSpent = Date.now() - startTime;
    const contentQuality = finalCheck.products > 0 ? 95 : 
                          finalCheck.hasRealContent ? 80 : 
                          finalCheck.links >= 5 ? 60 : 30;
    
    return {
      success: finalCheck.products > 0 || finalCheck.links >= 3 || finalCheck.hasRealContent,
      strategy,
      timeSpent,
      linksFound: finalCheck.links,
      contentQuality,
      criticalContentFound: finalCheck.products > 0 || criticalContentFound,
      productsDetected: finalCheck.products
    };
    
  } catch (error) {
    console.log(`  [Task ${taskNum}] âš ï¸ Wait strategy error: ${error}`);
    return {
      success: false,
      strategy: 'fallback',
      timeSpent: Date.now() - startTime,
      linksFound: 0,
      contentQuality: 10,
      criticalContentFound: false,
      productsDetected: 0
    };
  }
}

// ============================================
// ğŸ”¥ Ø¯ÙˆØ§Ù„ Ø§Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ø­Ø³Ù†Ø© (Ultimate Edition)
// ============================================

interface PageClassification {
  category: string;
  confidence: number;
  signals: string[];
  platform?: "salla" | "zid" | "nextjs" | "generic";
}

interface CrawlGoals {
  storeName: boolean;
  shipping: boolean;
  returns: boolean;
  products: number;
}

interface SupabaseDocument {
  project_id: string;
  content: string;
  metadata: object;
  embedding: number[];
}

interface ExtractionDiagnostics {
  url: string;
  platform: string;
  classification: string;
  confidence: number;
  waitStrategy: string;
  htmlLength: number;
  strategiesAttempted: string[];
  productsFound: number;
  extractionTime: number;
  issues: string[];
}

// ğŸ§  V4.1: Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ø°ÙƒÙŠ Ø§Ù„Ø¬Ø¯ÙŠØ¯
interface ProductStructurePattern {
  nameSelectors: string[];
  descriptionSelectors: string[];
  containerSelectors: string[];
  confidence: number;
  learnedFrom: string;
  platform: string;
}

// ğŸ”¥ V4.1: Ù…Ø­Ù„Ù„ Ø§Ù„Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø°ÙƒÙŠ
class SmartStructureAnalyzer {
  private patterns: Map<string, ProductStructurePattern> = new Map();
  
  analyzeProductPage($: cheerio.CheerioAPI, url: string, platform: string): ProductStructurePattern {
    console.log(`  [Structure Analyzer] ğŸ”¬ Analyzing product page structure...`);
    
    const pattern: ProductStructurePattern = {
      nameSelectors: [],
      descriptionSelectors: [],
      containerSelectors: [],
      confidence: 0,
      learnedFrom: url,
      platform
    };

    // ğŸ” Ø§ÙƒØªØ´Ø§Ù Ù…Ø­Ø¯Ø¯Ø§Øª Ø§Ù„Ø§Ø³Ù…
    const potentialNameSelectors = [
      'h1[itemprop="name"]',
      '.product-title',
      '.product-name', 
      '.product_title',
      '[data-product-name]',
      '.title',
      '.name',
      'h1'
    ];

    potentialNameSelectors.forEach(selector => {
      const elements = $(selector);
      if (elements.length > 0) {
        const text = elements.first().text().trim();
        if (text && text.length > 3 && !this.isGenericText(text)) {
          pattern.nameSelectors.push(selector);
          console.log(`  [Structure Analyzer] âœ… Name selector: ${selector} - "${text.substring(0, 30)}..."`);
        }
      }
    });

    // ğŸ” Ø§ÙƒØªØ´Ø§Ù Ù…Ø­Ø¯Ø¯Ø§Øª Ø§Ù„ÙˆØµÙ
    const potentialDescSelectors = [
      '[itemprop="description"]',
      '.product-description',
      '.description',
      '.product-details',
      '.product-info',
      '.desc',
      '.content',
      '.details'
    ];

    potentialDescSelectors.forEach(selector => {
      const elements = $(selector);
      if (elements.length > 0) {
        const text = elements.first().text().trim();
        if (text && text.length > 20 && !this.isGenericText(text)) {
          pattern.descriptionSelectors.push(selector);
          console.log(`  [Structure Analyzer] âœ… Description selector: ${selector} - "${text.substring(0, 50)}..."`);
        }
      }
    });

    // ğŸ” Ø§ÙƒØªØ´Ø§Ù Ù…Ø­Ø¯Ø¯Ø§Øª Ø§Ù„Ø­Ø§ÙˆÙŠØ©
    const potentialContainerSelectors = [
      '.product-details',
      '.product-info',
      '.product-container',
      '.product-page',
      '.product-main',
      '.details-container',
      '.product-content'
    ];

    potentialContainerSelectors.forEach(selector => {
      if ($(selector).length > 0) {
        pattern.containerSelectors.push(selector);
        console.log(`  [Structure Analyzer] âœ… Container selector: ${selector}`);
      }
    });

    // ğŸ“Š Ø­Ø³Ø§Ø¨ Ø§Ù„Ø«Ù‚Ø©
    pattern.confidence = this.calculateConfidence(pattern);
    console.log(`  [Structure Analyzer] ğŸ“Š Analysis confidence: ${pattern.confidence}%`);

    // Ø­ÙØ¸ Ø§Ù„Ù†Ù…Ø·
    const key = `${platform}_product`;
    this.patterns.set(key, pattern);

    return pattern;
  }

  private isGenericText(text: string): boolean {
    const genericPatterns = [
      /^(home|main|page|website|site|web|menu|navigation|nav)$/i,
      /^(Ø±Ø¦ÙŠØ³ÙŠØ©|Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©|Ù…ØªØ¬Ø±|Ù…Ù†ØªØ¬|Ù…Ù†ØªØ¬Ø§Øª|Ø¹Ø±Ø¶|Ø®ØµÙ…)$/i,
      /^\s*$/
    ];
    return genericPatterns.some(pattern => pattern.test(text));
  }

  private calculateConfidence(pattern: ProductStructurePattern): number {
    let score = 0;
    
    if (pattern.nameSelectors.length > 0) score += 40;
    if (pattern.descriptionSelectors.length > 0) score += 40;
    if (pattern.containerSelectors.length > 0) score += 20;
    
    // Ù…ÙƒØ§ÙØ£Ø© Ù„Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø©
    if (pattern.nameSelectors.length > 1) score += 10;
    if (pattern.descriptionSelectors.length > 1) score += 10;
    
    return Math.min(score, 100);
  }

  getPattern(platform: string): ProductStructurePattern | null {
    return this.patterns.get(`${platform}_product`) || null;
  }

  hasPattern(platform: string): boolean {
    return this.patterns.has(`${platform}_product`);
  }
}

// Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø­Ù„Ù„ Ø¹Ø§Ù„Ù…ÙŠ
const structureAnalyzer = new SmartStructureAnalyzer();

// ğŸ”¥ V4.1: Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø°ÙƒÙŠ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù…ØªØ¹Ù„Ù…Ø©
function extractWithLearnedPatterns(
  $: cheerio.CheerioAPI, 
  platform: string,
  isSingleProduct: boolean = false
): Array<{ name: string; description: string }> {
  
  const products: Array<{ name: string; description: string }> = [];
  const pattern = structureAnalyzer.getPattern(platform);
  
  if (!pattern) {
    console.log(`  [Smart Extractor] âš ï¸ No learned patterns for ${platform}`);
    return products;
  }

  console.log(`  [Smart Extractor] ğŸ§  Using learned patterns (confidence: ${pattern.confidence}%)`);

  if (isSingleProduct) {
    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ù†ØªØ¬ ÙØ±Ø¯ÙŠ
    let name = '';
    let description = '';

    // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø­Ø¯Ø¯Ø§Øª Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ù…ØªØ¹Ù„Ù…Ø©
    for (const selector of pattern.nameSelectors) {
      name = $(selector).first().text().trim();
      if (name && name.length > 3) {
        console.log(`  [Smart Extractor] âœ… Name from selector: ${selector}`);
        break;
      }
    }

    // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø­Ø¯Ø¯Ø§Øª Ø§Ù„ÙˆØµÙ Ø§Ù„Ù…ØªØ¹Ù„Ù…Ø©
    for (const selector of pattern.descriptionSelectors) {
      description = $(selector).first().text().trim();
      if (description && description.length > 20) {
        console.log(`  [Smart Extractor] âœ… Description from selector: ${selector}`);
        break;
      }
    }

    // ğŸ”¥ Ø§Ù„Ø´Ø±Ø· Ø§Ù„ØµØ§Ø±Ù…: ÙŠØ¬Ø¨ ÙˆØ¬ÙˆØ¯ ÙˆØµÙ Ø­Ù‚ÙŠÙ‚ÙŠ
    if (name && hasRealDescription(description)) {
      products.push({
        name: cleanProductName(name),
        description: cleanProductDescription(description)
      });
      console.log(`  [Smart Extractor] ğŸ¯ SUCCESS: Product "${name.substring(0, 30)}..." with valid description`);
    } else {
      console.log(`  [Smart Extractor] âŒ REJECTED: Product "${name.substring(0, 30)}..." - No valid description`);
    }

  } else {
    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ù†ØªØ¬Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø© Ù…Ù† ØµÙØ­Ø© ÙØ¦Ø©
    const containerSelectors = pattern.containerSelectors.length > 0 
      ? pattern.containerSelectors 
      : ['.product', '.product-item', '.product-card'];

    containerSelectors.forEach(containerSelector => {
      $(containerSelector).each((i, element) => {
        const $el = $(element);
        let name = '';
        let description = '';

        // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø­Ø¯Ø¯Ø§Øª Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ù…ØªØ¹Ù„Ù…Ø© Ø¯Ø§Ø®Ù„ Ø§Ù„Ø­Ø§ÙˆÙŠØ©
        for (const nameSelector of pattern.nameSelectors) {
          name = $el.find(nameSelector).first().text().trim();
          if (name && name.length > 3) break;
        }

        // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø­Ø¯Ø¯Ø§Øª Ø§Ù„ÙˆØµÙ Ø§Ù„Ù…ØªØ¹Ù„Ù…Ø© Ø¯Ø§Ø®Ù„ Ø§Ù„Ø­Ø§ÙˆÙŠØ©
        for (const descSelector of pattern.descriptionSelectors) {
          description = $el.find(descSelector).first().text().trim();
          if (description && description.length > 20) break;
        }

        // ğŸ”¥ Ø§Ù„Ø´Ø±Ø· Ø§Ù„ØµØ§Ø±Ù…: ÙŠØ¬Ø¨ ÙˆØ¬ÙˆØ¯ ÙˆØµÙ Ø­Ù‚ÙŠÙ‚ÙŠ
    if (name && hasRealDescription(description)) {
          const cleanName = cleanProductName(name);
          const cleanDesc = cleanProductDescription(description);
          
          // ØªØ¬Ù†Ø¨ Ø§Ù„ØªÙƒØ±Ø§Ø±
          if (!products.some(p => p.name === cleanName)) {
            products.push({ name: cleanName, description: cleanDesc });
            console.log(`  [Smart Extractor] âœ… Product: ${cleanName.substring(0, 30)}...`);
          }
        }
      });
    });
  }

  console.log(`  [Smart Extractor] ğŸ“Š Extracted ${products.length} products with valid descriptions`);
  return products;
}

// ğŸ”¥ V4.1: Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ ÙˆØµÙ Ø­Ù‚ÙŠÙ‚ÙŠ
function hasRealDescription(description: string): boolean {
  if (!description) return false;
  
  const cleanDesc = description.trim();
  
  // ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„ÙˆØµÙ Ø¨Ø·ÙˆÙ„ Ù…Ø¹Ù‚ÙˆÙ„
  if (cleanDesc.length < 15) return false;
  
  // ÙŠØ¬Ø¨ Ø£Ù„Ø§ ÙŠÙƒÙˆÙ† Ù†ØµØ§Ù‹ Ø¹Ø§Ù…Ø§Ù‹
  const genericDescriptions = [
    'Ù…Ù†ØªØ¬ Ù…Ù† Ø§Ù„Ù…ØªØ¬Ø±',
    'Ù…Ù†ØªØ¬ Ù…Ù† Ù…ØªØ¬Ø± Ø³Ù„Ø©', 
    'Ù…Ù†ØªØ¬ Ù…Ù† Ù…ØªØ¬Ø± Ø²Ø¯',
    'Ù…Ù†ØªØ¬ Ø¨Ø³Ø¹Ø±',
    'product',
    'item',
    'Ù…Ù†ØªØ¬'
  ];
  
  if (genericDescriptions.some(gen => cleanDesc.includes(gen))) {
    return false;
  }
  
  // ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù…Ø­ØªÙˆÙ‰ Ø­Ù‚ÙŠÙ‚ÙŠ
  const wordCount = cleanDesc.split(/\s+/).length;
  return wordCount >= 3;
}

// ğŸ”¥ V4.0: Ø¥Ù†Ø´Ø§Ø¡ ØªÙ‚Ø±ÙŠØ± ØªØ´Ø®ÙŠØµÙŠ
function createDiagnosticReport(
  taskNum: number,
  diagnostics: ExtractionDiagnostics
): void {
  console.log(`\nğŸ“‹ [DIAGNOSTIC REPORT - Task ${taskNum}]`);
  console.log(`ğŸ“ URL: ${diagnostics.url}`);
  console.log(`ğŸª Platform: ${diagnostics.platform}`);
  console.log(`ğŸ“„ Classification: ${diagnostics.classification} (${diagnostics.confidence}%)`);
  console.log(`â±ï¸ Wait Strategy: ${diagnostics.waitStrategy}`);
  console.log(`ğŸ“Š HTML Size: ${diagnostics.htmlLength} chars`);
  console.log(`ğŸ”§ Strategies: ${diagnostics.strategiesAttempted.join(', ')}`);
  console.log(`ğŸ›ï¸ Products Found: ${diagnostics.productsFound}`);
  console.log(`â° Extraction Time: ${diagnostics.extractionTime}ms`);
  
  if (diagnostics.issues.length > 0) {
    console.log(`ğŸš¨ Issues:`);
    diagnostics.issues.forEach(issue => console.log(`   - ${issue}`));
  }
  console.log(`ğŸ”š [END REPORT]\n`);
}

// ğŸ”¥ V4.0: Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø­Ø³Ù† Ù„Ø§Ø³Ù… Ø§Ù„Ù…ØªØ¬Ø±
function extractStoreName(
  $: cheerio.CheerioAPI,
  platform: PageClassification["platform"]
): string {
  let storeName = "";

  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ù† Open Graph Ø£ÙˆÙ„Ø§Ù‹
  storeName = $("meta[property='og:site_name']").attr("content") || "";

  // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ØŒ Ø¬Ø±Ø¨ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†
  if (!storeName) {
    storeName = $("title")
      .text()
      .split(/[|\-â€“â€”]/)[0]
      .trim();
  }

  // ØªÙ†Ø¸ÙŠÙ Ø´Ø§Ù…Ù„ ÙˆØ´Ø¯ÙŠØ¯
  storeName = storeName
    .replace(
      /(search|cart|arrow|menu|login|account|home|main|page|website|site|web|keyboard|right|left|share|star|rating|review|ØªÙ‚ÙŠÙŠÙ…|Ù†Ø¬ÙˆÙ…)/gi,
      ""
    )
    .replace(/[^\w\u0600-\u06FF\s\-&.,]/g, "")
    .replace(/\s+/g, " ")
    .trim();

  return storeName.length > 2 && storeName.length < 100 ? storeName : "";
}

// ğŸ”¥ V4.0: ØªÙ†Ø¸ÙŠÙ Ø§Ø³Ù… Ø§Ù„Ù…Ù†ØªØ¬
function cleanProductName(name: string): string {
  return name
    .replace(/(Ù…ØªØ¬Ø±|Ø±Ø¦ÙŠØ³ÙŠØ©|Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©|store|home|Ø¹Ø±Ø¶|Ø®ØµÙ…|Ø¬Ø¯ÙŠØ¯)/gi, "")
    .replace(/[^\w\u0600-\u06FF\s\-&.,]/g, "")
    .replace(/\s+/g, " ")
    .trim();
}

// ğŸ”¥ V4.0: ØªÙ†Ø¸ÙŠÙ ÙˆØµÙ Ø§Ù„Ù…Ù†ØªØ¬
function cleanProductDescription(description: string): string {
  return description
    .replace(/(star|rating|review|ØªÙ‚ÙŠÙŠÙ…|Ù†Ø¬ÙˆÙ…|\*)/gi, "")
    .replace(/[\d]+\s*ØªÙ‚ÙŠÙŠÙ…/g, "")
    .replace(/\s+/g, " ")
    .trim();
}

// ğŸ”¥ V4.1: Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ù†ØªØ¬Ø§Øª Ù…Ù† Salla - Ù…Ø¹ Ø§Ù„Ø´Ø±Ø· Ø§Ù„ØµØ§Ø±Ù…
function extractProductsFromSalla($: cheerio.CheerioAPI): Array<{ name: string; description: string }> {
  const products: Array<{ name: string; description: string }> = [];
  
  console.log("  [Salla Extractor] ğŸª Starting Salla-specific extraction...");
  
  // ğŸ¯ Ù…Ø­Ø¯Ø¯Ø§Øª Salla Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ©
  const sallaSelectors = [
    '.s-block-product-card',
    '.s-product-card-entry', 
    '[data-product-id]',
    '.product-entry',
    '.product-block',
    'article[data-product]',
  ];
  
  sallaSelectors.forEach(selector => {
    const elements = $(selector);
    console.log(`  [Salla Extractor] ğŸ” Testing selector: ${selector} - Found: ${elements.length} elements`);
    
    elements.each((i, element) => {
      const $el = $(element);
      
      // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø§Ø³Ù…
      const nameSelectors = [
        '.s-block-product-card__name',
        '.product-title',
        'h3.product-name',
        'h2',
        '[itemprop="name"]',
        '.s-block-product-card-entry__title',
      ];
      
      let name = '';
      for (const sel of nameSelectors) {
        name = $el.find(sel).first().text().trim();
        if (name && name.length > 3) break;
      }
      
      // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ÙˆØµÙ
      const descSelectors = [
        '.s-block-product-card__description',
        '.product-description',
        '[itemprop="description"]',
        '.product-excerpt',
      ];
      
      let description = '';
      for (const sel of descSelectors) {
        description = $el.find(sel).first().text().trim();
        if (description && description.length > 20) break;
      }
      
      // ğŸ”¥ Ø§Ù„Ø´Ø±Ø· Ø§Ù„ØµØ§Ø±Ù…: ÙŠØ¬Ø¨ ÙˆØ¬ÙˆØ¯ ÙˆØµÙ Ø­Ù‚ÙŠÙ‚ÙŠ
      if (name && hasRealDescription(description)) {
        const cleanName = cleanProductName(name);
        const cleanDesc = cleanProductDescription(description);
        
        // ØªØ¬Ù†Ø¨ Ø§Ù„ØªÙƒØ±Ø§Ø±
        if (!products.some(p => p.name === cleanName)) {
          products.push({ name: cleanName, description: cleanDesc });
          console.log(`  [Salla Extractor] âœ… Product: ${cleanName.substring(0, 40)}...`);
        }
      } else {
        console.log(`  [Salla Extractor] âŒ Skipped product - No valid description`);
      }
    });
  });
  
  console.log(`  [Salla Extractor] ğŸ“Š Total extracted: ${products.length} products with valid descriptions`);
  return products.slice(0, 25);
}

// ğŸ”¥ V4.1: Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ù†ØªØ¬Ø§Øª Ù…Ù† Zid - Ù…Ø¹ Ø§Ù„Ø´Ø±Ø· Ø§Ù„ØµØ§Ø±Ù…
function extractProductsFromZid($: cheerio.CheerioAPI): Array<{ name: string; description: string }> {
  const products: Array<{ name: string; description: string }> = [];
  
  console.log("  [Zid Extractor] ğŸª Starting Zid-specific extraction...");
  
  const zidSelectors = [
    '.z-product-card',
    '[data-zid-product]',
    '.product-item',
    'article.product',
  ];
  
  zidSelectors.forEach(selector => {
    $(selector).each((i, element) => {
      const $el = $(element);
      
      const name = $el.find('.z-product-card__title, h3, h2').first().text().trim();
      const description = $el.find('.z-product-card__description, .description').first().text().trim();
      
      // ğŸ”¥ Ø§Ù„Ø´Ø±Ø· Ø§Ù„ØµØ§Ø±Ù…: ÙŠØ¬Ø¨ ÙˆØ¬ÙˆØ¯ ÙˆØµÙ Ø­Ù‚ÙŠÙ‚ÙŠ
      if (name && name.length > 3 && hasRealDescription(description)) {
        const cleanName = cleanProductName(name);
        const cleanDesc = cleanProductDescription(description) || 'Ù…Ù†ØªØ¬ Ù…Ù† Ù…ØªØ¬Ø± Ø²Ø¯';
        
        if (!products.some(p => p.name === cleanName)) {
          products.push({ 
            name: cleanName, 
            description: cleanDesc 
          });
          console.log(`  [Zid Extractor] âœ… Product: ${name.substring(0, 40)}...`);
        }
      } else {
        console.log(`  [Zid Extractor] âŒ Skipped product - No valid description`);
      }
    });
  });
  
  return products.slice(0, 25);
}

// ğŸ”¥ V4.1: Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø°ÙƒÙŠØ© Ù…Ø¹ Ø§Ù„ØªØ¹Ù„Ù…
function intelligentProductExtraction(
  $: cheerio.CheerioAPI, 
  platform: string,
  url: string,
  taskNum: number,
  classification: PageClassification
): Array<{name: string; description: string}> {
  
  console.log(`  [Task ${taskNum}] ğŸ§  Starting intelligent extraction...`);
  
  const allProducts: Array<{name: string; description: string}> = [];
  const seenNames = new Set<string>();

  // ğŸ¯ Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© 1: Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù…ØªØ¹Ù„Ù…Ø© (Ø§Ù„Ø£ÙØ¶Ù„)
  if (structureAnalyzer.hasPattern(platform)) {
    console.log(`  [Task ${taskNum}] ğŸ§  Using learned patterns...`);
    const smartProducts = extractWithLearnedPatterns($, platform, classification.category === 'product_page');
    
    smartProducts.forEach(product => {
      if (!seenNames.has(product.name)) {
        seenNames.add(product.name);
        allProducts.push(product);
      }
    });
    
    if (smartProducts.length > 0) {
      console.log(`  [Task ${taskNum}] ğŸ‰ Smart extraction found ${smartProducts.length} products`);
      return allProducts.slice(0, 25);
    }
  }

  // ğŸ¯ Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© 2: Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ù†ØªØ¬ ÙØ±Ø¯ÙŠ Ù…Ù† ØµÙØ­Ø© Ù…Ù†ØªØ¬
  if (classification.category === "product_page") {
    console.log(`  [Task ${taskNum}] ğŸ¯ Single product page - using dedicated extractor...`);
    const singleProduct = extractSingleProductInfo($, classification.platform);
    
    // ğŸ”¥ Ø§Ù„Ø´Ø±Ø· Ø§Ù„ØµØ§Ø±Ù…: ÙŠØ¬Ø¨ ÙˆØ¬ÙˆØ¯ ÙˆØµÙ Ø­Ù‚ÙŠÙ‚ÙŠ
    if (singleProduct.name && hasRealDescription(singleProduct.description)) {
      allProducts.push({
        name: cleanProductName(singleProduct.name),
        description: cleanProductDescription(singleProduct.description)
      });
      console.log(`  [Task ${taskNum}] âœ… Single product extracted: ${singleProduct.name.substring(0, 40)}...`);
    } else {
      console.log(`  [Task ${taskNum}] âŒ Single product extraction failed - no valid description`);
    }
    
    if (allProducts.length > 0) {
      return allProducts;
    }
  }

  // ğŸ¯ Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© 3: Ø§Ø³ØªØ®Ø±Ø§Ø¬ ØªÙ‚Ù„ÙŠØ¯ÙŠ Ù…Ø¹ Ø§Ù„Ø´Ø±Ø· Ø§Ù„ØµØ§Ø±Ù…
  console.log(`  [Task ${taskNum}] ğŸ”§ Falling back to traditional extraction...`);
  
  const traditionalStrategies = [
    {
      name: "platform_specific",
      execute: () => {
        if (platform === 'salla') return extractProductsFromSalla($);
        if (platform === 'zid') return extractProductsFromZid($);
        return [];
      }
    },
    {
      name: "category_page_extraction", 
      execute: () => {
        const products: Array<{name: string; description: string}> = [];
        
        $('.products-grid, .product-list, .items-grid, [class*="products"]').each((i, container) => {
          $(container).find('.product, .item, [class*="product-"]').each((j, product) => {
            const $product = $(product);
            const name = $product.find('h3, h4, .title, .name, [class*="title"]').first().text().trim();
            const description = $product.find('.desc, .description, .excerpt').first().text().trim();
            
            // ğŸ”¥ Ø§Ù„Ø´Ø±Ø· Ø§Ù„ØµØ§Ø±Ù…
            if (name && hasRealDescription(description)) {
              products.push({
                name: cleanProductName(name),
                description: cleanProductDescription(description)
              });
            }
          });
        });
        
        return products;
      }
    }
  ];

  for (const strategy of traditionalStrategies) {
    try {
      console.log(`  [Task ${taskNum}] ğŸ”§ Trying strategy: ${strategy.name}`);
      const strategyProducts = strategy.execute();
      
      strategyProducts.forEach(product => {
        if (!seenNames.has(product.name)) {
          seenNames.add(product.name);
          allProducts.push(product);
        }
      });
      
      if (strategyProducts.length > 0) {
        console.log(`  [Task ${taskNum}] ğŸ‰ Strategy ${strategy.name} found ${strategyProducts.length} products`);
      }
      
    } catch (error) {
      console.log(`  [Task ${taskNum}] âš ï¸ Strategy ${strategy.name} failed: ${error}`);
    }
  }
  
  console.log(`  [Task ${taskNum}] ğŸ“Š Total extracted: ${allProducts.length} products with valid descriptions`);
  return allProducts.slice(0, 25);
}

// ğŸ”¥ V4.1: Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ù†ØªØ¬ ÙˆØ§Ø­Ø¯ Ù…Ø­Ø³Ù† Ù…Ø¹ Ø§Ù„Ø´Ø±Ø· Ø§Ù„ØµØ§Ø±Ù…
function extractSingleProductInfo(
  $: cheerio.CheerioAPI,
  platform: PageClassification["platform"]
): { name: string; description: string } {
  
  console.log(`  [Single Product Extractor] ğŸš€ Starting extraction... Platform: ${platform}`);
  
  let name = "";
  let description = "";

  try {
    const jsonLdScript = $("script[type='application/ld+json']");
    for (let i = 0; i < jsonLdScript.length; i++) {
      const scriptContent = $(jsonLdScript[i]).html();
      if (scriptContent && scriptContent.includes('"@type":"Product"')) {
        const productJson = JSON.parse(scriptContent);
        const productData = Array.isArray(productJson)
          ? productJson.find((item: any) => item["@type"] === "Product")
          : productJson;

        if (productData && productData.name) {
          name = productData.name;
          description = productData.description || "";
          if (name && hasRealDescription(description)) {
            console.log("  [Single Product Extractor] âœ… Extracted from JSON-LD");
            return {
              name: cleanProductName(name),
              description: cleanProductDescription(description),
            };
          }
        }
      }
    }
  } catch (e) {
    console.log("  [Single Product Extractor] âš ï¸ Could not parse JSON-LD");
  }

  // ØªØ­Ø¯ÙŠØ¯ Ø­Ø§ÙˆÙŠØ© Ø§Ù„Ù…Ù†ØªØ¬ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø£ÙˆÙ„Ø§Ù‹
  const productContainers = [
    ".product-details",
    ".product-info", 
    ".product-container",
    ".product-page",
    ".product-detail",
    ".product__info",
    ".product__details",
    ".product-main",
    ".product-content",
    ".product-summary",
    ".details-container",
    ".z-product-page",
  ];

  let productContainer: ReturnType<typeof $> | null = null;
  for (const container of productContainers) {
    const containerElement = $(container).first();
    if (containerElement.length > 0) {
      productContainer = containerElement;
      console.log(`  [Single Product Extractor] ğŸ” Found product container: ${container}`);
      break;
    }
  }

  if (platform === "salla") {
    name = $(".details-container h1.product-title").text().trim();
    if (!name && productContainer) {
      name = productContainer
        .find("h1.product-title, h1")
        .first()
        .text()
        .trim();
    }
    description = $(".product-description").text().trim();
    if (!description && productContainer) {
      description = productContainer
        .find(".product-description, .description")
        .first()
        .text()
        .trim();
    }
    if (name && hasRealDescription(description)) {
      console.log("  [Single Product Extractor] âœ… Extracted using Salla-specific selectors");
      return {
        name: cleanProductName(name),
        description: cleanProductDescription(description),
      };
    }
  } else if (platform === "zid") {
    name = $(".z-product-page__title-text").text().trim();
    if (!name && productContainer) {
      name = productContainer
        .find(".z-product-page__title-text, h1")
        .first()
        .text()
        .trim();
    }
    description = $(".z-product-page__description").text().trim();
    if (!description && productContainer) {
      description = productContainer
        .find(".z-product-page__description, .description")
        .first()
        .text()
        .trim();
    }
    if (name && hasRealDescription(description)) {
      console.log("  [Single Product Extractor] âœ… Extracted using Zid-specific selectors");
      return {
        name: cleanProductName(name),
        description: cleanProductDescription(description),
      };
    }
  }

  // Ø§Ù„Ø¨Ø­Ø« Ø¯Ø§Ø®Ù„ Ø­Ø§ÙˆÙŠØ© Ø§Ù„Ù…Ù†ØªØ¬ Ø£ÙˆÙ„Ø§Ù‹
  if (!name && productContainer) {
    name = productContainer
      .find("h1[itemprop='name'], .product-title, .product-name, h1")
      .first()
      .text()
      .trim();
  }
  if (!description && productContainer) {
    description = productContainer
      .find("[itemprop='description'], .product-description, .description")
      .first()
      .text()
      .trim();
  }

  // Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ù„Ø¹Ø¯ÙˆØ§Ù†ÙŠØ© ÙÙ‚Ø· Ø¥Ø°Ø§ ÙØ´Ù„ Ø§Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ù† Ø§Ù„Ø­Ø§ÙˆÙŠØ©
  if (!name) {
    name = $("h1[itemprop='name'], .product-title, .product-name, h1")
      .first()
      .text()
      .trim();
  }
  if (!description) {
    description = $(
      "[itemprop='description'], .product-description, .description"
    )
      .first()
      .text()
      .trim();
  }

  if (!name) {
    name = $("h1, [class*='title'] h1, [class*='product'] h1")
      .first()
      .text()
      .trim();
  }
  if (!description) {
    // Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ø·ÙˆÙŠÙ„Ø© ÙÙ‚Ø· Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
    const mainContent = $(
      "main, article, [role='main'], .main-content"
    ).first();
    const possibleDesc = mainContent
      .find("p, [class*='desc'], [class*='detail'], [class*='info']")
      .map((i, el) => $(el).text().trim())
      .get()
      .filter(
        (text) =>
          text.length > 50 &&
          text.length < 2000 &&
          !text.includes("Â©") &&
          !text.includes("Ø³ÙŠØ§Ø³Ø©") &&
          !text.match(/star|rating|review|ØªÙ‚ÙŠÙŠÙ…|Ù†Ø¬ÙˆÙ…/i)
      )
      .slice(0, 3)
      .join(" ");
    if (possibleDesc) description = possibleDesc;
  }

  if (!name) {
    name =
      $("meta[property='og:title']").attr("content") ||
      $("title")
        .text()
        .split(/[|\-â€“â€”]/)[0]
        .trim();
  }
  if (!description) {
    description =
      $("meta[property='og:description']").attr("content") ||
      $("meta[name='description']").attr("content") ||
      "";
  }

  const result = {
    name: cleanProductName(name),
    description: cleanProductDescription(description),
  };

  // ğŸ”¥ Ø§Ù„Ø´Ø±Ø· Ø§Ù„ØµØ§Ø±Ù… Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ
  if (!hasRealDescription(result.description)) {
    console.log(`  [Single Product Extractor] âŒ REJECTED: No valid description for product`);
    return { name: "", description: "" };
  }

  return result;
}

// ğŸ”¥ V4.0: ØªØµÙ†ÙŠÙ ØµÙØ­Ø§Øª Ù…Ø­Ø³Ù‘Ù†
function intelligentPageClassifierV4(
  url: string,
  html: string
): PageClassification {
  const $ = cheerio.load(html);
  const decodedUrl = decodeURIComponent(url).toLowerCase();
  const pageText = $("body").text().toLowerCase();
  const title = $("title").text().toLowerCase();
  const signals: string[] = [];
  let platform: PageClassification["platform"] = "generic";

  // ÙƒØ´Ù Ø§Ù„Ù…Ù†ØµØ© Ø§Ù„Ù…Ø­Ø³Ù†
  if (
    html.includes("salla.sa") ||
    html.includes("salla-bundle") ||
    $('script[src*="salla"]').length > 0
  ) {
    platform = "salla";
    signals.push("platform_salla");
  } else if ($("script[src*='zid.sa']").length > 0) {
    platform = "zid";
    signals.push("platform_zid");
  } else if ($("script#__NEXT_DATA__").length > 0) {
    platform = "nextjs";
    signals.push("platform_nextjs");
  }

  // ğŸ”¥ V4.0: ÙƒØ´Ù Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø¨Ø¯ÙˆÙ† Ù…Ù†Ø¹ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª
  const isHomePage =
    decodedUrl === "https://ryefal.com/" ||
    decodedUrl === "https://ryefal.com" ||
    $('body[class*="home"], [class*="home-page"]').length > 0;

  if (isHomePage) {
    return {
      category: "home_page",
      confidence: 100,
      signals: ["home_page_detected"],
      platform,
    };
  }

  // ğŸ”¥ V4.0: ØªØ­Ø³ÙŠÙ† ÙƒØ¨ÙŠØ± ÙÙŠ ÙƒØ´Ù Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª
  const productScoreRules = [
    // Ø£Ù†Ù…Ø§Ø· URLs Ù„Ù…Ù†ØµØ© Salla - Ø£ÙƒØ«Ø± ØªØ­Ø¯ÙŠØ¯Ø§Ù‹
    {
      test: () => decodedUrl.match(/\/product\/[a-zA-Z0-9-]+\/[0-9]+/),
      weight: 80,
      signal: "salla_product_url_pattern",
    },
    {
      test: () =>
        decodedUrl.includes("/product/") &&
        !decodedUrl.includes("/categories/"),
      weight: 70,
      signal: "product_url",
    },

    // Ù…Ø­Ø¯Ø¯Ø§Øª Salla Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© - Ø£ÙƒØ«Ø± Ø¯Ù‚Ø©
    {
      test: () =>
        platform === "salla" &&
        $(".product-details").length > 0 &&
        $(".product-details h1").length > 0,
      weight: 85,
      signal: "salla_product_details_with_title",
    },
    {
      test: () =>
        platform === "salla" &&
        $("[data-product-id]").length > 0 &&
        $("h1").length > 0,
      weight: 80,
      signal: "salla_product_data_with_title",
    },

    // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ø³Ù… ÙˆÙˆØµÙ Ø­Ù‚ÙŠÙ‚ÙŠ Ù„Ù„Ù…Ù†ØªØ¬
    {
      test: () => {
        const productName = $("h1").first().text().trim();
        return (
          productName &&
          productName.length > 5 &&
          !productName.match(/^(Ù…ØªØ¬Ø±|Ø±Ø¦ÙŠØ³ÙŠØ©|Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©)$/i)
        );
      },
      weight: 60,
      signal: "valid_product_name",
    },

    // Ù…Ø­Ø¯Ø¯Ø§Øª Ø¹Ø§Ù…Ø© Ù…Ø­Ø³Ù†Ø©
    {
      test: () => $("meta[property='og:type'][content='product']").length > 0,
      weight: 75,
      signal: "og_product",
    },
    {
      test: () =>
        $("script[type='application/ld+json']")
          .text()
          .includes('"@type":"Product"'),
      weight: 90,
      signal: "json_ld_product",
    },
    {
      test: () =>
        $(".add-to-cart, #add-to-cart, [class*='add-to-cart']").length > 0 &&
        $(".price").length > 0,
      weight: 65,
      signal: "add_to_cart_with_price",
    },
    {
      test: () => $(".price, [class*='price']").length > 0,
      weight: 45,
      signal: "price_element",
    },
  ];

  const productScore = productScoreRules.reduce((score, rule) => {
    if (rule.test()) {
      signals.push(rule.signal);
      return score + rule.weight;
    }
    return score;
  }, 0);

  // ØªØµÙ†ÙŠÙ ØµÙØ­Ø§Øª Ø§Ù„ÙØ¦Ø§Øª Ù…Ø­Ø³Ù‘Ù†
  const categoryScoreRules = [
    {
      test: () =>
        decodedUrl.match(
          /\/(categories?|category|collections?|collection|shop|store|Ù…ØªØ¬Ø±|ÙØ¦Ø§Øª|Ù…Ø¬Ù…ÙˆØ¹Ø§Øª)\//
        ),
      weight: 60,
      signal: "category_url_pattern",
    },
    {
      test: () => $("[class*='category'], [class*='collection']").length > 0,
      weight: 40,
      signal: "category_classes",
    },
    {
      test: () =>
        $(".products-grid, .product-list, .items-grid, [class*='products']")
          .length > 0,
      weight: 70,
      signal: "product_list_container",
    },
    {
      test: () =>
        $(".product-item, .product-card, [class*='product-']").length >= 3,
      weight: 80,
      signal: "multiple_product_items",
    },
  ];
  const categoryScore = categoryScoreRules.reduce((score, rule) => {
    if (rule.test()) {
      signals.push(rule.signal);
      return score + rule.weight;
    }
    return score;
  }, 0);

  // ØªØµÙ†ÙŠÙ ØµÙØ­Ø§Øª Ø§Ù„Ø´Ø­Ù† ÙˆØ§Ù„Ø¥Ø±Ø¬Ø§Ø¹
  const shippingKeywords = [
    "Ø´Ø­Ù†",
    "ØªÙˆØµÙŠÙ„",
    "shipping",
    "delivery",
    "dispatch",
    "courier",
    "Ø§Ù„Ø´Ø­Ù†",
    "Ø§Ù„ØªÙˆØµÙŠÙ„",
  ];
  const shippingScore = [
    {
      test: () => shippingKeywords.some((k) => decodedUrl.includes(k)),
      weight: 50,
      signal: "shipping_url",
    },
    {
      test: () => shippingKeywords.some((k) => title.includes(k)),
      weight: 45,
      signal: "shipping_title",
    },
  ].reduce(
    (score, s) =>
      s.test() ? (signals.push(s.signal), score + s.weight) : score,
    0
  );

  const returnKeywords = [
    "return",
    "refund",
    "Ø§Ø³ØªØ±Ø¬Ø§Ø¹",
    "Ø§Ø³ØªØ¨Ø¯Ø§Ù„",
    "exchange",
    "Ø±Ø¬ÙˆØ¹",
    "Ø¥Ø±Ø¬Ø§Ø¹",
    "Ø§Ù„Ø§Ø³ØªØ±Ø¬Ø§Ø¹",
    "Ø§Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„",
  ];
  const returnScore = [
    {
      test: () => returnKeywords.some((k) => decodedUrl.includes(k)),
      weight: 50,
      signal: "return_url",
    },
    {
      test: () => returnKeywords.some((k) => title.includes(k)),
      weight: 45,
      signal: "return_title",
    },
  ].reduce(
    (score, s) =>
      s.test() ? (signals.push(s.signal), score + s.weight) : score,
    0
  );

  // Ø£Ù†Ù…Ø§Ø· Ø§Ù„ØªØ¬Ø§Ù‡Ù„
  const ignorePatterns = [
    /\/(cart|checkout|login|register|account|profile|wishlist|password)/i,
    /\/(Ø³Ù„Ø©|Ø³Ù„ØªÙŠ|Ø­Ø³Ø§Ø¨ÙŠ|Ø§Ù„Ø¯ÙØ¹|ØªØ³Ø¬ÙŠÙ„|Ù…Ù‚Ø§Ø±Ù†Ø©|Ø§Ù„Ù…ÙØ¶Ù„Ø©)/,
    /\/(blogs|contact|about|faq)/i,
    /\.(pdf|jpg|jpeg|png|gif|svg|css|js|json|xml)$/i,
  ];
  if (ignorePatterns.some((p) => p.test(decodedUrl))) {
    return {
      category: "ignore",
      confidence: 100,
      signals: ["ignore_pattern"],
      platform,
    };
  }

  const scores = [
    { category: "product_page", score: productScore },
    { category: "category_page", score: categoryScore },
    { category: "shipping", score: shippingScore },
    { category: "returns", score: returnScore },
  ];
  const best = scores.reduce((max, curr) =>
    curr.score > max.score ? curr : max
  );

  // Ù‚Ø§Ø¹Ø¯Ø© Ø­Ø§Ø³Ù…Ø© Ù„Ù„ØªÙ…ÙŠÙŠØ² Ø¨ÙŠÙ† ØµÙØ­Ø© Ø§Ù„Ù…Ù†ØªØ¬ ÙˆØ§Ù„ÙØ¦Ø©
const productItemsCount = $(".product-item, .product-card, [class*='product-']").length;
if (productItemsCount > 2) {
    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø§Ù„Ø¹Ø¯ÙŠØ¯ Ù…Ù† Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…Ù†ØªØ¬Ø§ØªØŒ ÙÙ‡Ø°Ù‡ ØµÙØ­Ø© ÙØ¦Ø© Ø¨Ø§Ù„ØªØ£ÙƒÙŠØ¯.
    // ØªØ¬Ø§Ù‡Ù„ Ø£ÙŠ Ø¯Ø±Ø¬Ø© Ù„ØµÙØ­Ø© Ø§Ù„Ù…Ù†ØªØ¬ ÙˆØ£Ø¹Ø· Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ© Ù„Ù„ÙØ¦Ø©.
    if (best.category === 'product_page') {
        console.log(`  [Classifier Fix] âš ï¸ Corrected classification from 'product_page' to 'category_page' due to multiple items (${productItemsCount}).`);
        // Ø§Ø¨Ø­Ø« Ø¹Ù† Ø«Ø§Ù†ÙŠ Ø£ÙØ¶Ù„ Ù†ØªÙŠØ¬Ø© (ÙˆØ§Ù„ØªÙŠ Ø³ØªÙƒÙˆÙ† Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø±Ø¬Ø­ 'category_page')
        const secondBest = scores.filter(s => s.category !== 'product_page').reduce((max, curr) => curr.score > max.score ? curr : max);
        if (secondBest.score > 0) {
            return {
                category: secondBest.category,
                confidence: Math.min(100, secondBest.score),
                signals,
                platform,
            };
        }
    }
}

  // ğŸ”¥ V4.0: Ø¹ØªØ¨Ø§Øª Ø£ÙƒØ«Ø± Ø°ÙƒØ§Ø¡Ù‹
  if (best.score >= 60) {
    return {
      category: best.category,
      confidence: Math.min(100, best.score),
      signals,
      platform,
    };
  }
  return {
    category: "general",
    confidence: 0,
    signals: ["no_clear_match"],
    platform,
  };
}


function cleanContent($: cheerio.CheerioAPI): string {
  const unwantedSelectors = [
    "script",
    "style",
    "noscript",
    "iframe",
    "nav",
    "header",
    "footer",
    ".menu",
    ".navigation",
    ".advertisement",
    ".ads",
    ".social-share",
    ".cookie-banner",
    ".popup",
    ".modal",
  ];
  unwantedSelectors.forEach((selector) => $(selector).remove());
  let mainContent = $(
    'main, article, [role="main"], .main-content, .content, #content, .product-details, .page-content'
  )
    .first()
    .text();
  if (!mainContent || mainContent.length < 100) mainContent = $("body").text();
  return mainContent
    .replace(/\s+/g, " ")
    .replace(/[\n\r]+/g, "\n")
    .trim();
}

// ============================================
// ğŸš€ Ù†Ù‚Ø·Ø© Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø§Ù„Ù…Ø­Ø³Ù†Ø© - v4.1
// ============================================
export async function POST(request: Request) {
  const startTime = Date.now();
  let browser: Browser | null = null;

  try {
    const body = await request.json();
    const { url: baseUrl, projectId } = body;

    if (!baseUrl || !projectId) {
      return NextResponse.json(
        { error: "URL and projectId are required" },
        { status: 400 }
      );
    }

    // ğŸ”¥ ØªÙ‡ÙŠØ¦Ø© Supabase
    const supabaseAdmin = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    );
    console.log("[Supabase] Admin client initialized.");

    console.log(
      `\n${"=".repeat(60)}\nğŸ§  HYPER-CRAWLER v4.1 (AI-Powered Edition) ğŸ§ `
    );
    console.log(
      `ğŸ“ˆ Goals: 1 Store Name, 1 Shipping, 1 Returns, 27 Products\nğŸ”’ STRICT: Products must have valid descriptions\n${"=".repeat(60)}\n`
    );

    const MAX_CONCURRENT_TASKS = 5;
    const GOAL_PATIENCE_THRESHOLD = 50;
    const MAX_URL_QUEUE_SIZE = 300;

    console.log("[Embeddings] Initializing HuggingFace embeddings...");
    const langchainEmbeddings = new HuggingFaceTransformersEmbeddings({
      modelName: "Xenova/multilingual-e5-base",
    });

    // ğŸ”¥ Ø­Ø°Ù Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ù…Ù† Supabase
    console.log(`[Supabase] Deleting old documents for project: ${projectId}`);
    const { error: deleteError } = await supabaseAdmin
      .from("documents")
      .delete()
      .eq("project_id", projectId);

    if (deleteError) {
      console.error("[Supabase] Error deleting old documents:", deleteError);
    } else {
      console.log("[Supabase] Old documents deleted successfully.");
    }

    browser = await chromium.launch({
      headless: true,
      args: ["--disable-dev-shm-usage", "--no-sandbox"],
    });
    const context = await browser.newContext({
      userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
    });
    await context.route("**/*", (route) => {
      if (
        ["image", "stylesheet", "font", "media"].includes(
          route.request().resourceType()
        )
      )
        route.abort();
      else route.continue();
    });
    console.log(`[Playwright] Browser is ready.`);

    const goals: CrawlGoals = {
      storeName: false,
      shipping: false,
      returns: false,
      products: 0,
    };
    const urlsToVisit = new Map<string, number>([[baseUrl, 100]]);
    const visitedUrls = new Set<string>();
    let totalDocumentsProcessed = 0;
    const waitStrategyStats = new Map<string, number>();
    let patternLearningCompleted = false;

    const processUrlTask = async (
      url: string,
      taskNum: number
    ): Promise<void> => {
      console.log(`  [Task ${taskNum}] â¡ï¸  Visiting: ${url}`);
      const page = await context.newPage();
      let htmlContent: string | null = null;
      const diagnostics: ExtractionDiagnostics = {
        url,
        platform: 'unknown',
        classification: 'unknown',
        confidence: 0,
        waitStrategy: 'unknown',
        htmlLength: 0,
        strategiesAttempted: [],
        productsFound: 0,
        extractionTime: 0,
        issues: []
      };

      try {
        await page.goto(url, { waitUntil: "domcontentloaded", timeout: 25000 });

        // ğŸ¯ ØªØ·Ø¨ÙŠÙ‚ Ù†Ø¸Ø§Ù… Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ø°ÙƒÙŠ
        const waitResult = await intelligentWaitStrategyV4(page, url, taskNum);
        
        diagnostics.waitStrategy = waitResult.strategy;
        diagnostics.platform = waitResult.strategy.includes('salla') ? 'salla' : 
                              waitResult.strategy.includes('zid') ? 'zid' : 
                              waitResult.strategy.includes('nextjs') ? 'nextjs' : 'generic';

        waitStrategyStats.set(
          waitResult.strategy,
          (waitStrategyStats.get(waitResult.strategy) || 0) + 1
        );

        console.log(
          `  [Task ${taskNum}] ğŸ“Š Wait Result: Strategy='${waitResult.strategy}', Time=${waitResult.timeSpent}ms, Products=${waitResult.productsDetected}`
        );

        // Ø£Ø®Ø° HTML Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
        htmlContent = await page.content();
        diagnostics.htmlLength = htmlContent.length;

      } catch (error: any) {
        console.error(
          `  [Task ${taskNum}] âŒ Error during page processing: ${error.name}`
        );
        diagnostics.issues.push(`Page load error: ${error.name}`);
        await page.close();
        return;
      }

      await page.close();

      const $ = cheerio.load(htmlContent!);

      // ğŸ”¥ V4.1: Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ¹Ù„Ù… - ØªØ­Ù„ÙŠÙ„ Ø£ÙˆÙ„ ØµÙØ­Ø© Ù…Ù†ØªØ¬
      const classification = intelligentPageClassifierV4(url, htmlContent!);
      diagnostics.classification = classification.category;
      diagnostics.confidence = classification.confidence;

      console.log(
        `  [Task ${taskNum}] ğŸ•µï¸  Classification: '${classification.category}', Platform='${classification.platform}', Confidence=${classification.confidence}%`
      );

      if (classification.category === "ignore") return;

      // ğŸ§  Ø§Ù„ØªØ¹Ù„Ù… Ù…Ù† Ø£ÙˆÙ„ ØµÙØ­Ø© Ù…Ù†ØªØ¬
      if (classification.category === "product_page" && classification.platform && !patternLearningCompleted) {
        console.log(`  [Task ${taskNum}] ğŸ§  LEARNING: Analyzing product page structure...`);
        structureAnalyzer.analyzeProductPage($, url, classification.platform);
        patternLearningCompleted = true;
        console.log(`  [Task ${taskNum}] ğŸ§  LEARNING: Pattern analysis completed!`);
      }

      // ğŸ”— Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·
      $("a[href]").each((i, link) => {
        if (urlsToVisit.size >= MAX_URL_QUEUE_SIZE) return;
        try {
          const href = $(link).attr("href");
          if (!href) return;
          const absoluteUrl = new URL(href, baseUrl)
            .toString()
            .split("#")[0]
            .split("?")[0];
          if (
            absoluteUrl.startsWith(baseUrl) &&
            !visitedUrls.has(absoluteUrl) &&
            !urlsToVisit.has(absoluteUrl)
          ) {
            let priority = 1;
            const linkText = $(link).text().toLowerCase();
            const decodedUrl = decodeURIComponent(absoluteUrl).toLowerCase();

            // Ø£ÙˆÙ„ÙˆÙŠØ© Ø¹Ø§Ù„ÙŠØ© Ù„Ù„Ø³ÙŠØ§Ø³Ø§Øª
            const policyPatterns = ['shipping', 'delivery', 'Ø´Ø­Ù†', 'ØªÙˆØµÙŠÙ„', 
                                    'return', 'refund', 'Ø§Ø³ØªØ±Ø¬Ø§Ø¹', 'Ø§Ø³ØªØ¨Ø¯Ø§Ù„', 
                                    'policy', 'Ø³ÙŠØ§Ø³Ø©'];
            
            if (policyPatterns.some(p => decodedUrl.includes(p) || linkText.includes(p))) {
              priority = 100;
            }
            
            // Ø£ÙˆÙ„ÙˆÙŠØ© Ø¹Ø§Ù„ÙŠØ© Ù„ØµÙØ­Ø§Øª Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª ÙˆØ§Ù„ÙØ¦Ø§Øª
            else if (goals.products < 27) {
              const isCategoryPage = 
                decodedUrl.match(/\/(categories?|collections?|shop|store|products|Ù…ØªØ¬Ø±|Ø£Ù‚Ø³Ø§Ù…|Ù…Ù†ØªØ¬Ø§Øª)/i) ||
                linkText.match(/(categories?|collections?|shop|products|Ø£Ù‚Ø³Ø§Ù…|Ù…Ù†ØªØ¬Ø§Øª)/i);
              
              if (isCategoryPage) priority = 98;
              
              const isProductPage = 
                decodedUrl.match(/\/product\/[a-zA-Z0-9-]+\/[0-9]+/) ||
                (decodedUrl.includes('/product/') && !decodedUrl.includes('/categories/'));
              
              if (isProductPage) priority = 95;
              
              if (decodedUrl === baseUrl || decodedUrl === baseUrl + '/') {
                priority = 97;
              }
            }
            
            if (priority > 1) {
              urlsToVisit.set(absoluteUrl, Math.max(urlsToVisit.get(absoluteUrl) || 0, priority));
            }
          }
        } catch (e) {
          // ignore invalid URLs
        }
      });

      const documentsToEmbed: { content: string; metadata: any }[] = [];
      const extractionStartTime = Date.now();

      // ğŸ”¥ V4.1: Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ø³Ù… Ø§Ù„Ù…ØªØ¬Ø±
      if (!goals.storeName) {
        const storeName = extractStoreName($, classification.platform);
        if (storeName) {
          const metadata = {
            source: url,
            category: "store_name",
            projectId,
            confidence: 90,
            platform: classification.platform,
          };
          documentsToEmbed.push({
            content: `Ø§Ø³Ù… Ø§Ù„Ù…ØªØ¬Ø±: ${storeName}`,
            metadata,
          });
          console.log(`  [Task ${taskNum}] ğŸª Store Name Found: ${storeName}`);
          goals.storeName = true;
        }
      }

      // ğŸ”¥ V4.1: Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø³ÙŠØ§Ø³Ø§Øª Ø§Ù„Ø´Ø­Ù† ÙˆØ§Ù„Ø¥Ø±Ø¬Ø§Ø¹
      if (classification.category === "shipping" && !goals.shipping) {
        const cleanedContent = cleanContent($);
        if (cleanedContent.length > 50) {
          const metadata = {
            source: url,
            category: "shipping",
            projectId,
            confidence: classification.confidence,
          };
          documentsToEmbed.push({ content: cleanedContent, metadata });
          goals.shipping = true;
          console.log(`  [Task ${taskNum}] ğŸ“¦ Shipping policy extracted`);
        }
      }
      if (classification.category === "returns" && !goals.returns) {
        const cleanedContent = cleanContent($);
        if (cleanedContent.length > 50) {
          const metadata = {
            source: url,
            category: "returns",
            projectId,
            confidence: classification.confidence,
          };
          documentsToEmbed.push({ content: cleanedContent, metadata });
          goals.returns = true;
          console.log(`  [Task ${taskNum}] ğŸ”„ Returns policy extracted`);
        }
      }

      // ğŸ”¥ V4.1: Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ù…Ø¹ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø°ÙƒÙŠ
      if (goals.products < 27) {
        console.log(`  [Task ${taskNum}] ğŸ›ï¸ Starting product extraction...`);
        
        let extractedProducts: Array<{ name: string; description: string }> = [];
        diagnostics.strategiesAttempted.push('intelligent_extraction');

        // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø°ÙƒÙŠ Ù„Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬
        extractedProducts = intelligentProductExtraction(
          $, 
          classification.platform || 'generic', 
          url, 
          taskNum, 
          classification
        );

        // ğŸ”¥ Ø§Ù„Ø´Ø±Ø· Ø§Ù„ØµØ§Ø±Ù…: Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† Ù„Ù‡Ø§ ÙˆØµÙ Ø­Ù‚ÙŠÙ‚ÙŠ
        extractedProducts.forEach(product => {
          if (goals.products >= 27) return;
          
          if (hasRealDescription(product.description)) {
            const content = `Ø§Ø³Ù… Ø§Ù„Ù…Ù†ØªØ¬: ${product.name}\nÙˆØµÙ Ø§Ù„Ù…Ù†ØªØ¬: ${product.description}`;
            const metadata = {
              source: url,
              category: 'product_info',
              projectId,
              productName: product.name,
              confidence: classification.confidence || 70,
              extractionMethod: 'intelligent_v4.1',
              pageType: classification.category,
              hasValidDescription: true
            };
            
            documentsToEmbed.push({ content, metadata });
            goals.products++;
            console.log(`  [Task ${taskNum}] â• ADDED: "${product.name.substring(0, 30)}..." (${goals.products}/27)`);
          } else {
            console.log(`  [Task ${taskNum}] âŒ REJECTED: "${product.name.substring(0, 30)}..." - No valid description`);
          }
        });

        diagnostics.productsFound = extractedProducts.length;
        
        if (extractedProducts.length === 0) {
          diagnostics.issues.push('No products with valid descriptions found');
        }
      }

      diagnostics.extractionTime = Date.now() - extractionStartTime;
      createDiagnosticReport(taskNum, diagnostics);

      // ğŸ”¥ Ø¥Ø¯Ø±Ø§Ø¬ ÙÙŠ Supabase
      if (documentsToEmbed.length > 0) {
        console.log(
          `  [Task ${taskNum}] ğŸ§  Generating embeddings for ${documentsToEmbed.length} document(s)...`
        );
        const contents = documentsToEmbed.map((d) => d.content);
        const embeddings = await langchainEmbeddings.embedDocuments(contents);

        const supabaseDocs: SupabaseDocument[] = documentsToEmbed.map(
          (doc, i) => ({
            project_id: projectId,
            content: doc.content,
            metadata: doc.metadata,
            embedding: embeddings[i],
          })
        );

        const { error: insertError } = await supabaseAdmin
          .from("documents")
          .insert(supabaseDocs);

        if (insertError) {
          console.error(
            `  [Task ${taskNum}] âŒ Supabase insert error:`,
            insertError.message
          );
        } else {
          console.log(
            `  [Task ${taskNum}] âœ… Successfully inserted ${supabaseDocs.length} document(s) into Supabase.`
          );
          totalDocumentsProcessed += supabaseDocs.length;
        }
      }
    };

    // [Ù†ÙØ³ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø³Ø§Ø¨Ù‚ Ù„Ù„Ø­Ù„Ù‚Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ÙˆØ¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù‡Ø§Ù…]
    // ... (Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø­Ø§Ù„ÙŠ Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù‡Ø§Ù… ÙˆØ§Ù„Ø­Ù„Ù‚Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©)

    const runningTasks: Promise<void>[] = [];
    let taskCounter = 0;
    const mainLoop = async () => {
      while (true) {
        if (!browser || !browser.isConnected()) {
          console.log("âŒ Browser closed unexpectedly, stopping crawl...");
          break;
        }

        if (
          visitedUrls.size > GOAL_PATIENCE_THRESHOLD &&
          runningTasks.length === 0
        ) {
          if (!goals.shipping) {
            console.log(`ğŸŸ¡ Patience threshold reached for 'shipping'. Giving up.`);
            goals.shipping = true;
          }
          if (!goals.returns) {
            console.log(`ğŸŸ¡ Patience threshold reached for 'returns'. Giving up.`);
            goals.returns = true;
          }
        }

        if (
          (goals.storeName && goals.shipping && goals.returns && goals.products >= 27) ||
          (urlsToVisit.size === 0 && runningTasks.length === 0) ||
          !browser?.isConnected()
        ) {
          break;
        }

        while (
          runningTasks.length < MAX_CONCURRENT_TASKS &&
          urlsToVisit.size > 0 &&
          browser?.isConnected()
        ) {
          const sortedUrls = Array.from(urlsToVisit.entries())
            .sort((a, b) => b[1] - a[1]);

          if (sortedUrls.length > 0) {
            const nextUrl = sortedUrls[0][0];
            urlsToVisit.delete(nextUrl);
            
            if (visitedUrls.has(nextUrl)) continue;
            visitedUrls.add(nextUrl);

            const task = processUrlTask(nextUrl, ++taskCounter);
            runningTasks.push(task);

            task
              .catch((error) => {
                console.error(`  [Task ${taskCounter}] âŒ Task failed: ${error.message}`);
              })
              .finally(() => {
                const index = runningTasks.indexOf(task);
                if (index > -1) runningTasks.splice(index, 1);
              });
          }
        }

        if (runningTasks.length > 0) {
          await Promise.race(runningTasks);
        } else if (urlsToVisit.size > 0 && browser?.isConnected()) {
          await new Promise((resolve) => setTimeout(resolve, 500));
        } else {
          await new Promise((resolve) => setTimeout(resolve, 100));
        }
      }
    };

    await mainLoop();
    if (runningTasks.length > 0) {
      console.log(`â³ Waiting for ${runningTasks.length} remaining tasks...`);
      await Promise.allSettled(runningTasks);
    }

    const duration = ((Date.now() - startTime) / 1000).toFixed(2);
    console.log(`\n${"=".repeat(60)}\nâœ… HYPER-CRAWLER v4.1 COMPLETED!`);
    console.log(`â±ï¸  Duration: ${duration}s`);
    console.log(`ğŸ”— URLs visited: ${visitedUrls.size}`);
    console.log(`ğŸ§  Pattern Learning: ${patternLearningCompleted ? 'SUCCESS' : 'NOT_USED'}`);
    console.log(`--- WAIT STRATEGY STATISTICS ---`);
    waitStrategyStats.forEach((count, strategy) => {
      console.log(`  ${strategy}: ${count} times`);
    });
    console.log(`--- FINAL GOAL STATUS ---`);
    console.log(`Store Name Found: ${goals.storeName}`);
    console.log(`Shipping Info Found: ${goals.shipping}`);
    console.log(`Returns Info Found: ${goals.returns}`);
    console.log(`Products Found: ${goals.products} / 27`);
    console.log(`Products With Valid Descriptions: ${goals.products}`);
    console.log(`Overall Accuracy: ${((goals.products / 27) * 100).toFixed(1)}%`);
    console.log(`${"=".repeat(60)}\n`);

    // ğŸ”¥ ØªØ­Ø¯ÙŠØ« timestamp Ù„Ù„Ù…Ø´Ø±ÙˆØ¹
    try {
      const newCrawlVersion = uuidv4();
      const { error: updateError } = await supabaseAdmin
        .from("projects")
        .update({ crawl_version: newCrawlVersion })
        .eq("id", projectId);

      if (updateError) {
        console.error("[Realtime Trigger] Failed to update project timestamp:", updateError);
      } else {
        console.log(`[Realtime Trigger] Successfully updated project ${projectId}`);
      }
    } catch (e) {
      console.error("[Realtime Trigger] Critical error during project update:", e);
    }

    return NextResponse.json(
      {
        success: true,
        message: "Hyper-Crawler v4.1 completed with AI-powered learning!",
        stats: {
          duration: `${duration}s`,
          urlsVisited: visitedUrls.size,
          documentsProcessed: totalDocumentsProcessed,
          goals,
          accuracy: `${((goals.products / 27) * 100).toFixed(1)}%`,
          patternLearning: patternLearningCompleted,
          waitStrategies: Object.fromEntries(waitStrategyStats),
        },
      },
      { status: 200 }
    );
  } catch (error) {
    console.error("\nâŒ CRITICAL ERROR:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    return NextResponse.json(
      { success: false, error: "Internal server error", details: errorMessage },
      { status: 500 }
    );
  } finally {
    if (browser && browser.isConnected()) {
      await browser.close();
      console.log("[Playwright] Browser closed safely.");
    }
  }
}